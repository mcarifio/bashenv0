T 1600044812 19*	Now talking on 22#haskell-beginners
T 1600044812 22*	Topic for 22#haskell-beginners is: A quieter channel for beginner Haskell questions | No one around? Your questions are welcome in #haskell, too!
T 1600044812 22*	Topic for 22#haskell-beginners set by 26glguy (24Fri Aug 14 12:52:42 2020)
T 1600096283 18<invaser18>	Hi guys, wanted to ask whether there is a function in haskell that matches windows() function in Rust on slices
T 1600096380 18<yushyin18>	you would need to explain to us what it does
T 1600096397 18<invaser18>	e.g. on string "haskell" with size 2 it would produce ["ha","as","sk","ke","el","ll"]
T 1600096445 18<invaser18>	windows [1,3,4,5] 3 = [[1,3,4], [3,4,5]]
T 1600096464 18<merijn18>	> let f cs = zipWith (\a b -> [a,b]) cs (tail cs) in f "Haskell"
T 1600096467 18<lambdabot18>	 ["Ha","as","sk","ke","el","ll"]
T 1600096501 18<merijn18>	There's probably something somewhere
T 1600096515 18<merijn18>	But it's not particularly common
T 1600096524 18<invaser18>	merijn: thx for the answer, just was interested maybe there was something already in Prelude
T 1600096535 18<invaser18>	thx a lot
T 1600097029 18<ja18>	:m +Data.List.Split
T 1600097038 18<ja18>	> :m +Data.List.Split
T 1600097040 18<lambdabot18>	 <hint>:1:1: error: <hint>:1:1: error: parse error on input â€˜:â€™
T 1600097045 18<ja18>	% :m +Data.List.Split
T 1600097045 18<yahb18>	ja:
T 1600097053 18<ja18>	% :t chunksOf
T 1600097053 18<yahb18>	ja: Int -> [e] -> [[e]]
T 1600097065 18<ja18>	% chunksOf 2 "Haskell"
T 1600097065 18<yahb18>	ja: ["Ha","sk","el","l"]
T 1600097077 18<ja18>	ah, not the same at all
T 1600097093 18<yushyin18>	ja: more like divvy from the same package
T 1600097218 18<yushyin18>	% divvy 2 1 "Haskell"
T 1600097219 18<yahb18>	yushyin: ["Ha","as","sk","ke","el","ll"]
T 1600097692 18<ja18>	yushyin: cool, i would never have guessed that name lol
T 1600097790 18<ja18>	the longer i do haskell, the more of a lifestyle it becomes... there is so much satisfaction in being clever and having cool precise abstractions and your own vocabulary
T 1600097814 18<ja18>	it is like an antidote to having done CRUD interfaces for too long :O
T 1600097875 18<ja18>	not trying to start a flamewar here, but i just think it so interesting from a psychological perspective that programming has so much sociology and culture
T 1600097962 18<ja18>	my roommate escews capitalism and is an artist... when i look at his life, where being poor is almost a virtue, i can't be ashamed of building incomprehensible abstractions just to apply them twice ;O hahaha
T 1600098830 18<yushyin18>	ja: don't know why it is called divvy either. after you tried chunksOf from split I thought, yeah IF we have something similiar to rust's windows it is most likely defined in split, so I searched it quickly and found divvy.
T 1600098879 18<invaser18>	haha, that's a really weird name for a function, never would've thought of it
T 1600179044 18<nicolasochem18>	Hi, can anyone assist me with https://github.com/cryptiumlabs/backerei/issues/62
T 1600179064 18<nicolasochem18>	I am trying to do something simple - remove an element from a list, but it won't work because my list is of type `IO`
T 1600179088 18<nicolasochem18>	this is not my project, I am attempting to fix a bug
T 1600180258 18<dminuoso18>	nicolasochem: Hiya!
T 1600180308 18<nicolasochem18>	hi dminuoso
T 1600180320 18<dminuoso18>	nicolasochem: So the error message is saying:
T 1600180332 18<dminuoso18>	The entirety of the expression `(RPC.delegatedContracts config snapshotBlockHash delegate)`
T 1600180347 18<dminuoso18>	It expected (for some reason) that expressions type to be [Text]
T 1600180363 18<dminuoso18>	But it determined (for anothe rreason) that this expressions type actually is `IO [Text]`
T 1600180397 18<dminuoso18>	The expected type is due to the surrounding code, presumably because `delete` expects something of type `[Text]` as its second argument.
T 1600180436 18<nicolasochem18>	I see
T 1600180463 18<dminuoso18>	So the real question is "What exactly is a value of type `IO [Text]`, and how do you get [Text] out of it"
T 1600180507 18<dminuoso18>	Very roughly, IO denotes that the expression is not a list of texts, but rather an action that, if it were executed, would as the result of its execution, produce a list of texts.
T 1600180514 18<dminuoso18>	nicolasochem: Does this make sense?
T 1600180532 18<nicolasochem18>	yes
T 1600180546 18<nicolasochem18>	but I am not sure I want to get [Text] out of it
T 1600180571 18<nicolasochem18>	since I have an object of type IO [T.Text], and all I am trying to do is to remove an element from it
T 1600180577 18<dminuoso18>	You don't, directly
T 1600180580 18<dminuoso18>	The trick is this:
T 1600180596 18<dminuoso18>	The entirety of the binding you are in is of type `IO T` (for some choice of type T, it doesn't matter!)
T 1600180599 18<dminuoso18>	So far so good?
T 1600180606 18<dminuoso18>	So you're already writing up some "action"
T 1600180651 18<dminuoso18>	Maybe, we should start with sometihng simpler.
T 1600180668 18<dminuoso18>	% :t getLine
T 1600180668 18<yahb18>	dminuoso: IO String
T 1600180675 18<dminuoso18>	So this action, if executed, produced a string.
T 1600180695 18<nicolasochem18>	you kind of list me
T 1600180707 18<dminuoso18>	k
T 1600180711 18<nicolasochem18>	lost*
T 1600180721 18<dminuoso18>	nicolasochem: Let's start from the beginning then, perhaps.
T 1600180732 18<nicolasochem18>	the reason it's of type `IO` I believe is because it's an rpc call
T 1600180741 18<dminuoso18>	Its not of type `IO`
T 1600180770 18<dminuoso18>	But really, lets make a simpler example so you can understand whats going on
T 1600180777 18<nicolasochem18>	ok
T 1600180784 18<dminuoso18>	Do you know what `main` is in a haskell program?
T 1600180823 18<nicolasochem18>	it's the main function, of type io
T 1600180828 18<dminuoso18>	It's not a function!
T 1600180832 18<dminuoso18>	It's an action. A recipe.
T 1600180843 18<dminuoso18>	And its not of type IO, but rather `IO a` for some arbitrar ycohice of a
T 1600180860 18<dminuoso18>	So for example, `main :: IO String; main = getLine` is a valid Haskell program
T 1600180876 18<nicolasochem18>	ok
T 1600180879 18<dminuoso18>	In this particular example
T 1600180913 18<dminuoso18>	Think of `IO String` as some abstract type that, internally, contains assembly instructions that, if they were ever executed, would produce a string as their esult.
T 1600180919 18<dminuoso18>	Does that so far make sense?
T 1600180928 18<nicolasochem18>	yes
T 1600180942 18<dminuoso18>	Great. These assembly instructoins could do all kinds of funny stuff like draw things on your screen, we dont know.
T 1600180950 18<dminuoso18>	First, I want to assert something:
T 1600180966 18<dminuoso18>	If I evaluated that list of assembly instructions, what would happen?
T 1600180990 18<dminuoso18>	(Imagine the assembly instructions would draw a popup on the screen, asking for your name)
T 1600180995 18<dminuoso18>	Would you get the popup?
T 1600181044 18<nicolasochem18>	what do you mean by "if I evaluated"
T 1600181049 18<dminuoso18>	Ah
T 1600181056 18<dminuoso18>	Alright. Far enough, ignore that question then.
T 1600181063 18<dminuoso18>	So
T 1600181085 18<dminuoso18>	We have a list of things that are prefilled with (conceptual) "assembly instructions"
T 1600181087 18<dminuoso18>	for instance
T 1600181090 18<dminuoso18>	% :t getLine
T 1600181090 18<yahb18>	dminuoso: IO String
T 1600181119 18<dminuoso18>	We provide you with this primitive. Think of it as containing all the assembly instructoins necessary to talk to the terminal, to get a prompt, wait for input, and then get the result back
T 1600181128 18<dminuoso18>	Now
T 1600181136 18<dminuoso18>	We have another primitive
T 1600181139 18<dminuoso18>	% :t putStrLn
T 1600181139 18<yahb18>	dminuoso: String -> IO ()
T 1600181154 18<dminuoso18>	This takes a string, and then produces an action that, if it was executed, would print the provided string
T 1600181183 18<dminuoso18>	How can we compose these two together, such that we can action that first asks for input, and then prints it?
T 1600181192 18<dminuoso18>	We use a simple function (>>=) :: IO a -> (a -> IO b) -> IO b
T 1600181198 18<nicolasochem18>	ok
T 1600181203 18<dminuoso18>	So we can just say
T 1600181216 18<dminuoso18>	main = getLine >>= \l -> putStrLn l
T 1600181220 18<dminuoso18>	Does this so far make sense?
T 1600181239 18<nicolasochem18>	yes
T 1600181251 18<dminuoso18>	Important point to make:
T 1600181261 18<dminuoso18>	main is still not a function, and >>= doesn't "execute"
T 1600181272 18<dminuoso18>	it just lets us build up more complex "actions/assembly bags"
T 1600181281 18<nicolasochem18>	I see
T 1600181286 18<dminuoso18>	where we can look at the result of a previous action, and then decide what next thing to do
T 1600181295 18<dminuoso18>	so this >>= is what lets us pretend we can "peek inside"
T 1600181310 18<dminuoso18>	Now
T 1600181324 18<dminuoso18>	There's another version that disregards the result, and just sequences two together
T 1600181327 18<dminuoso18>	It's called >>
T 1600181342 18<dminuoso18>	So we can do: main = putStrLn "Who are you?" >> getLine >>= \l -> putStrLn l
T 1600181362 18<dminuoso18>	Building up a more complex action. At the end, the type of `main` is `IO ()` here
T 1600181368 18<dminuoso18>	nicolasochem: So far so good?
T 1600181399 18<nicolasochem18>	yes. I think
T 1600181420 18<dminuoso18>	Now, Haskell provides us with syntax sugar that looks a bit more natural and intuitive, but really just desugars into the above
T 1600181422 18<dminuoso18>	It's called "do-notation"
T 1600181435 18<dminuoso18>	So do-notation is not needed, and its not magical. It just desugars into uses of >>= and >>
T 1600181439 18<dminuoso18>	So the above code could be written as:
T 1600181443 18<dminuoso18>	main = do
T 1600181448 18<dminuoso18>	  putStrLn "Who are you?"
T 1600181455 18<dminuoso18>	  l <- getLine
T 1600181458 18<dminuoso18>	  putStrLn l
T 1600181477 18<nicolasochem18>	ok, makes sense
T 1600181479 18<dminuoso18>	Line breaks are desugared into >> or >>= depending on whether the next line contains a <-
T 1600181519 18<dminuoso18>	So if you had another `foo :: IO Int` that you wanted to print
T 1600181524 18<nicolasochem18>	yes. the code I am working on has plenty of `do`
T 1600181537 18<dminuoso18>	Then you need to tie it into that sequencing
T 1600181542 18<dminuoso18>	So for instance:
T 1600181546 18<dminuoso18>	main = do
T 1600181549 18<dminuoso18>	  putStrLn "Who are you?"
T 1600181553 18<dminuoso18>	  l <- getLine
T 1600181556 18<dminuoso18>	  putStrLn l
T 1600181559 18<dminuoso18>	  n <- foo
T 1600181562 18<dminuoso18>	  print n
T 1600181607 18<dminuoso18>	The only reason we can sort of "draw out the result of foo", is because we happen to be inside main and that's already in IO
T 1600181612 18<dminuoso18>	If it weren't, we couldn't
T 1600181617 18<dminuoso18>	And that's a good thing.
T 1600181629 18<nicolasochem18>	yes
T 1600181657 18<dminuoso18>	So just take your expression in your issue, insert a new line above, and use <- to "bind its result" to an identifier
T 1600181666 18<dminuoso18>	Similarly to how I tied `foo` or `getLine` in
T 1600181694 18<nicolasochem18>	ok, let me try
T 1600181903 18<nicolasochem18>	still no dice
T 1600181924 18<nicolasochem18>	  delegatorsRaw <- RPC.delegatedContracts config snapshotBlockHash delegate                                                                                                                                                                                                                                                     delegators <- delete delegate
T 1600181925 18<nicolasochem18>	delegatorsRaw
T 1600181931 18<nicolasochem18>	  delegatorsRaw <- RPC.delegatedContracts config snapshotBlockHash delegate  delegators <- delete delegate delegatorsRaw
T 1600181942 18<nicolasochem18>	sorry
T 1600181949 18<nicolasochem18>	I did
T 1600181952 18<nicolasochem18>	`  delegatorsRaw <- RPC.delegatedContracts config snapshotBlockHash delegate`
T 1600181958 18<nicolasochem18>	`  delegators <- delete delegate delegatorsRaw`
T 1600182016 18<nicolasochem18>	and I get another type matching error https://gist.github.com/nicolasochem/bb762e3e6b277595f4e03015e5d3030c
T 1600182215 18<ski18>	what's the type of `delete' ?
T 1600182268 18<nicolasochem18>	delete :: Eq a => a -> [a] -> [a]
T 1600182279 18<nicolasochem18>	it's from data.list
T 1600182279 18<nicolasochem18>	https://hackage.haskell.org/package/base-4.14.0.0/docs/Data-List.html
T 1600182282 18<ski18>	ok
T 1600182288 18<ski18>	then i guess you possibly wanted
T 1600182294 18<ski18>	  let delegators = delete delegate delegatorsRaw
T 1600182334 18<nicolasochem18>	it compiled now, let me check
T 1600182340 18<ski18>	(since `delete delegate delegatorsRaw' is not an `IO'-action, you don't want to execute it here, which is what `<-' expresses)
T 1600182413 18<ski18>	btw, if you don't want to bother with naming `delegatorsRaw', you could say something like
T 1600182431 18<ski18>	  delegators <- delete delegate <$> RPC.delegatedContracts config snapshotBlockHash delegate
T 1600182531 18<nicolasochem18>	my bug is now fixed, thank you very much
T 1600182563 18<ski18>	what do you think of that `<$>' suggestion ?
T 1600182605 18<nicolasochem18>	it's nicer
T 1600182730 18<nicolasochem18>	and it works too
T 1600182748 18<nicolasochem18>	thanks dminuoso ski
T 1600182809 18<ski18>	yw :)
T 1600190495 18<dyeplexer18>	What may be the reasons that I may not want to use this function for calculating averages?:
T 1600190497 18<dyeplexer18>	avg xs = q / p where g = foldl (\(a, b) c -> (a + 1, b + c)) (0, 0) xs; p = fst g; q = snd g;
T 1600190593 18<ski18>	it's not forcing the additions, until the end
T 1600190594 18<hyperisco18>	dyeplexer, is this your homework?
T 1600190600 18<dyeplexer18>	no
T 1600190632 18<ski18>	btw, you could say `(p,q) = foldl ...', instead of using `fst' and `snd'
T 1600190665 18<dyeplexer18>	ski: lazy evaluation?
T 1600190675 18<dyeplexer18>	Is that the reason to use foldl'
T 1600190715 18<dyeplexer18>	instead of foldl, to avoid stack overflows?
T 1600190798 18<dyeplexer18>	(I am basing the question on commonly available online solutions to this, such as here: https://stackoverflow.com/questions/2376981/haskell-types-frustrating-a-simple-average-function)
T 1600190929 18<ski18>	> let avg xs = q / p where g = foldl (\(a,b) c -> (a + 1,b + c)) (0,0) xs; p = fst g; q = snd g in avg [0 .. 4000000]
T 1600190936 18<lambdabot18>	 mueval-core: Time limit exceeded
T 1600190939 18<ski18>	> let avg xs = q / p where g = foldl' (\(a,b) c -> (a + 1,b + c)) (0,0) xs; p = fst g; q = snd g in avg [0 .. 4000000]
T 1600190945 18<lambdabot18>	 mueval-core: Time limit exceeded
T 1600190949 18<ski18>	> let avg xs = q / p where g = foldl' (\(!a,!b) c -> (a + 1,b + c)) (0,0) xs; p = fst g; q = snd g in avg [0 .. 4000000]
T 1600190955 18<lambdabot18>	 2000
T 1600190990 18<ski18>	hm
T 1600190994 18<ski18>	> let avg xs = q / p where g = foldl' (\(!a,!b) c -> (a + 1,b + c)) (0,0) xs; p = fst g; q = snd g in avg [0 .. 4000000]
T 1600191000 18<lambdabot18>	 2000000.0
T 1600191019 18<ski18>	(i guess the output got clipped, for some reason, at first ..)
T 1600191072 18<ski18>	dyeplexer : you want to avoid building up a huge unevaluated expression (in this case of additions)
T 1600191230 18<dyeplexer18>	ski: do the "!"s force strict evaluation on the additions?
T 1600191281 18<ski18>	they force those parts of the pair to be reduced, when matching the current state on that pair pattern
T 1600191331 18<dyeplexer18>	okay. So foldl' would force strict evaluation if avg was put in a subexpression of a larger expression, and the "!"s force strict evaluation on the pair. Is that correct?
T 1600191395 18<ski18>	i dunno what you mean by "if avg was put in a subexpression of a larger expression"
T 1600191436 18<dyeplexer18>	say if we did k = 225 + 343 + avg [1, 2, 3, 4]. Will it force k to be evaluated immediately?
T 1600191441 18<ski18>	foldl'  will make sure that the outermost constructor of the state is forced, as we progress iterating over the list
T 1600191461 18<ski18>	however, forcing `(1 + 1,2 + 3)' doesn't force the additions
T 1600191499 18<ski18>	dyeplexer : no
T 1600191520 18<dyeplexer18>	Okay
T 1600191532 18<ski18>	`k' is only evaluated (assuming plain by-need / lazy evaluation, that is barring any optimizations), if its value is needed/demanded/forced
T 1600191686 18<ski18>	@src foldl
T 1600191687 18<lambdabot18>	foldl f z []     = z
T 1600191687 18<lambdabot18>	foldl f z (x:xs) = foldl f (f z x) xs
T 1600191689 18<ski18>	@src foldl'
T 1600191689 18<lambdabot18>	foldl' f a []     = a
T 1600191689 18<lambdabot18>	foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
T 1600191726 18<ski18>	have you seen how these definitions work, on some example reduction ?
T 1600191759 18<dyeplexer18>	No, I think I should
T 1600191810 18<ski18>	well, consider e.g.
T 1600191811 18<dyeplexer18>	The book (learn you a haskell (...)) I'm following doesn't go into details (Or I haven't noticed it yet)
T 1600191833 18<ski18>	     foldl (+) 0 (2:3:5:7:[])
T 1600191849 18<ski18>	  =  foldl (+) (0 + 2) (3:5:7:[])
T 1600191857 18<ski18>	  =  foldl (+) ((0 + 2) + 3) (5:7:[])
T 1600191865 18<ski18>	  =  foldl (+) (((0 + 2) + 3) + 5) (7:[])
T 1600191877 18<ski18>	  =  foldl (+) ((((0 + 2) + 3) + 5) + 7) []
T 1600191887 18<ski18>	  =  (((0 + 2) + 3) + 5) + 7
T 1600191893 18<ski18>	  =  ((2 + 3) + 5) + 7
T 1600191897 18<ski18>	  =  (5 + 5) + 7
T 1600191899 18<dyeplexer18>	I have seen this, actually (I didn't know what you meant by reduction)
T 1600191902 18<ski18>	  =  10 + 7
T 1600191904 18<ski18>	  =  17
T 1600191958 18<ski18>	ok, so you can see that the additions build up, in the accumulator/state parameter, without being performed, until after we've reached the end of the list, and it's obvious that we're going to need the value of the accumulator (since it's the result in the base case)
T 1600192064 18<ski18>	with a strictness analyzer, an implementation may be able to notice that it will definitely need the value of the accumulator, in the end, and that that will require/demand/force the value of all the intermediate versions of the accumulator as well (since `(+)' is strict in its left operand), so that it can optimize the code by actually performing each addition as it goes, forcing the accumulator in each step
T 1600192095 18<ski18>	however, barring something like that, plain lazy / by-need reduction/evaluation will reduce the expression as above
T 1600192115 18<ski18>	the `seq' function could have been defined like
T 1600192122 18<ski18>	  seq !x y = y
T 1600192171 18<ski18>	it makes sure to force the first parameter, if the result of the `seq' call is forced
T 1600192203 18<ski18>	(or more properly, it makes sure that if `x' is bottom, then the result of the `seq' call is bottom)
T 1600192256 18<ski18>	in the definition of  foldl'  above, the next version of the accumulator is passed to `seq', so that it will be forced
T 1600192335 18<dyeplexer18>	Got it
T 1600192343 18<ski18>	(a Haskell implementation isn't required to force `x' on the spot, when `seq' is called. but the behaviour (not including efficiency concerns) of the program should be the same as if it did. and probably it will do it, unless it sees any reason not to, which presumably would be a more efficient way of computing the result)
T 1600192411 18<ski18>	(if you actually want to ensure `x' is forced before something else, you should use `pseq' (can be important for getting parallel evaluation right, get the expected performance). but normally you wouldn't need to use that)
T 1600192431 18<ski18>	oh, and the `!<pat>' patterns are equivalent to calling `seq'
T 1600192480 18<dyeplexer18>	Okay, Thanks for the explanation
T 1600192485 18<ski18>	(`seq' was invented before `BangPatterns' were invented. if the latter had been invented first, then maybe `seq' wouldn't have been introduced)
T 1600192503 18<dminuoso18>	ski: I think that assessment is not correct.
T 1600192507 18<dyeplexer18>	Wait
T 1600192512 18<ski18>	which ?
T 1600192514 18<dminuoso18>	Unlike bang patterns, seq has no implicit ordering.
T 1600192524 18<dminuoso18>	bang patterns is rather equivalent to pseq
T 1600192551 18<dyeplexer18>	Oh, that was my question. seq !x y = y was kind of a circular definition then
T 1600192625 18<ski18>	dminuoso : are you sure ?
T 1600192651 18<dminuoso18>	ski: Its hard to say since bang patterns are not part of standard Haskell, so we dont have a formal setting to know its semantics.
T 1600192686 18<dminuoso18>	Ah
T 1600192710 18<ski18>	<https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#dynamic-semantics-of-bang-patterns> doesn't seem to mention `pseq', but does mention `seq'
T 1600192721 18<dminuoso18>	Mmm
T 1600192729 18<dminuoso18>	You're right.
T 1600192764 18<ski18>	dyeplexer : yes, you'd take one or the other as the primitive
T 1600192772 18<dyeplexer18>	okay
T 1600192902 18<dyeplexer18>	Alright, thanks
T 1600202649 18<Plazma18>	!books
T 1600205021 18<ski18>	Plazma : wanted any book suggestions ?
T 1600205045 18<Plazma18>	Yea I figured the bot would have a list so I'd not bug people
T 1600205134 18<ski18>	some are :
T 1600205140 18<ski18>	@where PIH
T 1600205140 18<lambdabot18>	"Programming in Haskell" by Graham Hutton in 2007-01-15,2016-09-01 at <http://www.cs.nott.ac.uk/~pszgmh/pih.html>
T 1600205147 18<ski18>	@where LYAH
T 1600205147 18<lambdabot18>	http://www.learnyouahaskell.com/
T 1600205153 18<ski18>	@where HPFFP
T 1600205153 18<lambdabot18>	"Haskell Programming: from first principles - Pure functional programming without fear or frustration" by Chistopher Allen (bitemyapp),Julie Moronuki at <http://haskellbook.com/>,#haskell-beginners
T 1600205161 18<ski18>	@where SOE
T 1600205161 18<lambdabot18>	"The Haskell School of Expression: Learning Functional Programming through Multimedia" by Paul Hudak in 2000 at <http://www.cs.yale.edu/homes/hudak/SOE/>,<http://haskell.org/soe/> [broken]
T 1600205167 18<ski18>	@where HR
T 1600205167 18<lambdabot18>	"The Haskell Road to Logic, Maths and Programming", by Kees Doets,Jan van Eijck, at <http://homepages.cwi.nl/~jve/HR/> (broken ?),<https://web.archive.org/web/20190528043209/https://homepages.cwi.nl/
T 1600205167 18<lambdabot18>	~jve/HR/>
T 1600205171 18<ski18>	@where HTAC
T 1600205172 18<lambdabot18>	"Haskell Tutorial and Cookbook" by Mark Watson in 2017-09-04 at <https://leanpub.com/haskell-cookbook>
T 1600205176 18<ski18>	@where wikibook
T 1600205176 18<qu1j0t318>	ski: Thompson?
T 1600205177 18<lambdabot18>	http://en.wikibooks.org/wiki/Haskell
T 1600205202 18<ski18>	and "Haskell: The Craft of Functional Programming", by Simon Thompson (which is the one i learned from)
T 1600205211 18<qu1j0t318>	:)
T 1600205255 18<ja18>	apropos books, did someone read http://algebradriven.design ? recommended?
T 1600205260 18<ski18>	(not sure if there's a common abbreviation for that one)
T 1600205297 18<ja18>	it has a 80 page sample :O
T 1600205314 18*	ski hadn't heard of it before
T 1600205366 18<ski18>	(i have heard of "Thinking with Types: Type-Level Programming in Haskell" <https://leanpub.com/thinking-with-types>, though)
T 1600205918 18<Plazma18>	Which do you suggest for a beginner ski
T 1600205991 18<ski18>	i haven't read, or looked at, most of them
T 1600206035 18<ski18>	i thought Thompson was nice
T 1600206073 18<ski18>	i've not that seldom heard some other people suggest PIH, or said it was good
T 1600206109 18<Plazma18>	Huh?
T 1600206134 18<ski18>	LYAH has be criticized for not having exercises, and for not explaining the covered things enough in depth
T 1600206145 18<ski18>	(has been likened to a "four hour long trailer")
T 1600206192 18<ski18>	it has pretty pictures, though, and is pretty welcoming. it was probably an improvement on resources available freely on the web, when it came out
T 1600206198 18<ski18>	@where CIS194
T 1600206198 18<lambdabot18>	https://www.seas.upenn.edu/~cis194/spring13/lectures.html
T 1600206208 18<ski18>	has exercises, that you could try
T 1600206249 18<ski18>	i've heard some people like HPFFP quite much (it's intended to be usable by people who've never programmed before), and some others not as much
T 1600206259 18<ski18>	it's quite long, verbose
T 1600249423 18<teto18>	using nixUnstable, would it be possible to revert the stacktrace to display the final error at the bottom. The new error display is verbose and it's annoying to have to scroll everytime
T 1600337834 18<adauguet18>	Hi everyone, I am following the examples in the book Practical Web Development with Haskell, and wondering how I could rewrite a function without the use of ExceptT and runExceptT
T 1600337871 18<adauguet18>	class Monad m => AuthRepo m where  addAuth :: Auth -> m (Either RegistrationError VerificationCode)class Monad m => EmailVerificationNotif m where  notifyEmailVerification :: Email -> VerificationCode -> m ()register :: (AuthRepo m, EmailVerificationNotif m) => Auth -> m (Either RegistrationError ())register auth = runExceptT $ do  vCode <- ExceptT
T 1600337871 18<adauguet18>	$ addAuth auth  let email = authEmail auth  lift $ notifyEmailVerification email vCode
T 1600337933 18<dminuoso18>	adauguet: ExceptT internally just wraps the result inside some `Either E`. (>>=) then additionally pattern matches on the result, proceeding only if its Right (giving you the result), shortcircuiting otherwise. :)
T 1600337946 18<adauguet18>	https://gist.github.com/adauguet/15ce2ec8318a23557077f8ed0e045fd8
T 1600337980 18<adauguet18>	okay
T 1600338004 18<dminuoso18>	So `vCode <- addAuth auth; case r of Left e -> ...; Right r -> notifyEmailVerification (authEmail auth) vCode`
T 1600338026 18<dminuoso18>	ExceptT starts to become useful, if you have lots of things that can return Either, and you only want to proceed if *all* of them give you Right
T 1600338038 18<dminuoso18>	Such that "Left" acts as an exception of sorts, that is caught at the "runExceptT"
T 1600338176 18<dminuoso18>	adauguet: See the commend I made
T 1600338277 18<dminuoso18>	adauguet: Made some mistakes, fixed them. :)
T 1600338329 18<dminuoso18>	Oh. And I had a brainfart
T 1600338341 18<dminuoso18>	notifyEmailVerification (authEmail auth) <$> addAuth auth
T 1600338349 18<dminuoso18>	Mmm
T 1600338352 18<dminuoso18>	no
T 1600338356 18<adauguet18>	ok thx, i did not know about `pure` or `<$>`
T 1600338370 18<dminuoso18>	<$> is just infix fmap
T 1600338372 18<dminuoso18>	and pure is just return
T 1600338377 18<adauguet18>	ok
T 1600338384 18<dminuoso18>	Ignore my comment here last
T 1600338392 18<dminuoso18>	The two comments in your gist should be right
T 1600442279 18<adauguet18>	Hi everyone, I have an error I cannot fix: https://gist.github.com/adauguet/84540317925005ad13fcf6cea518c6fc
T 1600442382 18<adauguet18>	could you please help me?
T 1600442390 18<adauguet18>	Could not deduce (MonadIO Maybe) arising from a use of â€˜throwStringâ€™
T 1600442497 18<ski18>	push the `return' into the first branch
T 1600442618 18<adauguet18>	It works, but I have no idea why
T 1600442623 18<adauguet18>	thank you!
T 1600442703 18<ski18>	your `case result of ...' had type `Maybe `D.UserId', so `throwString' didn't work there
T 1600442743 18<adauguet18>	Yes this is what the error message was saying: cant use throwString there budy
T 1600442762 18<adauguet18>	so it is because of that `Maybe` ?
T 1600442763 18<ski18>	`throwString ..' had an effect that you wanted to perform in `m'. moving the `return' meant that the `case'-expression instead got type `m (Maybe D.UserId)'
T 1600442821 18<ski18>	btw, if you find yourself using `m (Maybe Blah)' much (especially if you get nested `case's on the `Maybe's), you may want to look into using `MaybeT m Blah' instead
T 1600442837 18<adauguet18>	`MaybeT` ok
T 1600442844 18<adauguet18>	thank you
T 1600442894 18<ski18>	but perhaps you'd rather want to replace the `Maybe' with using `throwString' (or something), as soon as possible
T 1600445551 18<hololeap18>	MaybeT lets you do `(a -> m (Maybe b)) -> (b -> m (Maybe c)) -> ...` without thinking about it
T 1600449527 18<wgytfr7818>	My privats videos skype webcam 400gb links open in Tor Browser gg.gg/m7dgu
T 1600525659 18<Batoeh18>	Good morning. Is there anywhere I can download a pdf of the ghc guide and haskell language report?
T 1600527446 18<ChaiTRex18>	Batoeh: Here's the language report: https://www.haskell.org/definition/haskell2010.pdf
T 1600527526 18<ChaiTRex18>	Batoeh: Here's the user's guide: https://downloads.haskell.org/ghc/latest/docs/users_guide.pdf
T 1600528689 18<Batoeh18>	ChaiTRex: thank you so much. I was having trouble finding them. Sorry if it was pretty obvious there it was.
T 1600580612 18<moondaddi18>	hello haskellers!
